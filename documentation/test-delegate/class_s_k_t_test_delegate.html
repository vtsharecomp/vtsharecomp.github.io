<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Test Delegate: SKTTestDelegate Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="VirtiumLogo.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Test Delegate
   &#160;<span id="projectnumber">1.0.1</span>
   </div>
   <div id="projectbrief">Test Delegate API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_s_k_t_test_delegate-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SKTTestDelegate Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_storage_kit_test_delegate_8h_source.html">StorageKitTestDelegate.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aecc4032aaee08b7c6f8eb4b5d21c1816"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#aecc4032aaee08b7c6f8eb4b5d21c1816">SKTTestDelegate</a> (SKStorageDevice *storageDevice, SKDeviceInfo *deviceInfo, bool loadWrittenLbasFromFile=true, bool freeStorageDevice=true)</td></tr>
<tr class="memdesc:aecc4032aaee08b7c6f8eb4b5d21c1816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that sets the storage device to a given value.  <a href="#aecc4032aaee08b7c6f8eb4b5d21c1816">More...</a><br /></td></tr>
<tr class="separator:aecc4032aaee08b7c6f8eb4b5d21c1816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0d861c72b763e76b2bde4c2f328989"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a7c0d861c72b763e76b2bde4c2f328989">~SKTTestDelegate</a> ()</td></tr>
<tr class="memdesc:a7c0d861c72b763e76b2bde4c2f328989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor that frees up memory.  <a href="#a7c0d861c72b763e76b2bde4c2f328989">More...</a><br /></td></tr>
<tr class="separator:a7c0d861c72b763e76b2bde4c2f328989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a53f075777687fa04173bc2efcd5ba"><td class="memItemLeft" align="right" valign="top">const SKDeviceInfo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a77a53f075777687fa04173bc2efcd5ba">getDeviceInfo</a> () const</td></tr>
<tr class="memdesc:a77a53f075777687fa04173bc2efcd5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get instance pointer of device info.  <a href="#a77a53f075777687fa04173bc2efcd5ba">More...</a><br /></td></tr>
<tr class="separator:a77a53f075777687fa04173bc2efcd5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc6c0bb31013a0ecf4adf5506fa8524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a5dc6c0bb31013a0ecf4adf5506fa8524">readLBA</a> (U64 lba, U32 sectorCount, SKAlignedBuffer *buffer)</td></tr>
<tr class="memdesc:a5dc6c0bb31013a0ecf4adf5506fa8524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to perform direct read from a storage device. <br />
User specifies logical block address, number of sectors, and provides a buffer that contains read contents.  <a href="#a5dc6c0bb31013a0ecf4adf5506fa8524">More...</a><br /></td></tr>
<tr class="separator:a5dc6c0bb31013a0ecf4adf5506fa8524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f419fc0e074bf3faccf3163b1c55831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a5f419fc0e074bf3faccf3163b1c55831">writeLBA</a> (U64 lba, U32 sectorCount, SKAlignedBuffer *buffer)</td></tr>
<tr class="memdesc:a5f419fc0e074bf3faccf3163b1c55831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to perform direct write to a storage device. <br />
User specifies logical block address, number of sectors, and provides a buffer that contains write contents.  <a href="#a5f419fc0e074bf3faccf3163b1c55831">More...</a><br /></td></tr>
<tr class="separator:a5f419fc0e074bf3faccf3163b1c55831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1650ce1ef4c16593d4a950dc78dedf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a0c1650ce1ef4c16593d4a950dc78dedf">sequentialWriteWithUniquePatterns</a> (U64 startLba, U64 endLba, U32 blockSizeInKB)</td></tr>
<tr class="memdesc:a0c1650ce1ef4c16593d4a950dc78dedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes unique data pattern for each LBA. <br />
The data (written lbas) will be marked and stored on file. This file will be used for verification of data integrity. The marked written lbas file format is the combination of the device model and '_lba.log'. <br />
The writes are sequential. This function is useful in the following situations:  <a href="#a0c1650ce1ef4c16593d4a950dc78dedf">More...</a><br /></td></tr>
<tr class="separator:a0c1650ce1ef4c16593d4a950dc78dedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6f15d6814f37378ba7a3b898cf41fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a5a6f15d6814f37378ba7a3b898cf41fe">sequentialRead</a> (U64 startLba, U64 endLba, U32 blockSizeInKB)</td></tr>
<tr class="memdesc:a5a6f15d6814f37378ba7a3b898cf41fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential read.  <a href="#a5a6f15d6814f37378ba7a3b898cf41fe">More...</a><br /></td></tr>
<tr class="separator:a5a6f15d6814f37378ba7a3b898cf41fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1208defc74b67bdb4b1c486dea6087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a5a1208defc74b67bdb4b1c486dea6087">randomWriteWithUniquePatterns</a> (U64 startLba, U64 endLba, U32 blockSizeInKB, U32 sizeInMB, U32 seed)</td></tr>
<tr class="memdesc:a5a1208defc74b67bdb4b1c486dea6087"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes unique data pattern for each LBA. <br />
The data (written LBAs) will be marked and stored on file. This file will be used for verification of data integrity. The marked written LBAs file format is the combination of the device model and '_lba.log'. <br />
The writes are random. This function is useful in the following situations:  <a href="#a5a1208defc74b67bdb4b1c486dea6087">More...</a><br /></td></tr>
<tr class="separator:a5a1208defc74b67bdb4b1c486dea6087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093e3555e092155feb9c19f40f33e90d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a093e3555e092155feb9c19f40f33e90d">randomRead</a> (U64 startLba, U64 endLba, U32 blockSizeInKB, U32 sizeInMB, U32 seed)</td></tr>
<tr class="memdesc:a093e3555e092155feb9c19f40f33e90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random read.  <a href="#a093e3555e092155feb9c19f40f33e90d">More...</a><br /></td></tr>
<tr class="separator:a093e3555e092155feb9c19f40f33e90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544ac08a737b1045095deb23b8e6ba5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a544ac08a737b1045095deb23b8e6ba5d">verifyDataIntegrity</a> ()</td></tr>
<tr class="memdesc:a544ac08a737b1045095deb23b8e6ba5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify data integrity. <br />
All marked written lbas will be read from the drive and use the information in the data itself to verify whether the data is OK or corrupted.  <a href="#a544ac08a737b1045095deb23b8e6ba5d">More...</a><br /></td></tr>
<tr class="separator:a544ac08a737b1045095deb23b8e6ba5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25f9f0d4aabe6c159b08c751c3fce6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#ad25f9f0d4aabe6c159b08c751c3fce6a">cleanupWorkloadDataFile</a> ()</td></tr>
<tr class="memdesc:ad25f9f0d4aabe6c159b08c751c3fce6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up workload data file which contains marked written lbas.  <a href="#ad25f9f0d4aabe6c159b08c751c3fce6a">More...</a><br /></td></tr>
<tr class="separator:ad25f9f0d4aabe6c159b08c751c3fce6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352d1c5033473624451b30e54117d316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a352d1c5033473624451b30e54117d316">sequentialReadPerformanceTest</a> (<a class="el" href="struct_s_k_t_benchmark_specific_setup.html">SKTBenchmarkSpecificSetup</a> &amp;benchSpec, <a class="el" href="struct_s_k_t_benchmark_report.html">SKTBenchmarkReport</a> &amp;reportInfo)</td></tr>
<tr class="memdesc:a352d1c5033473624451b30e54117d316"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a sequential read test on the storage device and return performance data. <br />
The performance data is calculated based on the amount data read and duration of the test.  <a href="#a352d1c5033473624451b30e54117d316">More...</a><br /></td></tr>
<tr class="separator:a352d1c5033473624451b30e54117d316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223a0b6bfc90fe5ccdd43e8e966daeb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a223a0b6bfc90fe5ccdd43e8e966daeb0">sequentialWritePerformanceTest</a> (<a class="el" href="struct_s_k_t_benchmark_specific_setup.html">SKTBenchmarkSpecificSetup</a> &amp;benchSpec, <a class="el" href="struct_s_k_t_benchmark_report.html">SKTBenchmarkReport</a> &amp;reportInfo)</td></tr>
<tr class="memdesc:a223a0b6bfc90fe5ccdd43e8e966daeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a sequential write test on the storage device and return performance data. <br />
The performance data is calculated based on the amount data written and duration of the test.  <a href="#a223a0b6bfc90fe5ccdd43e8e966daeb0">More...</a><br /></td></tr>
<tr class="separator:a223a0b6bfc90fe5ccdd43e8e966daeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3d1518a010dbb1c0d28d5360a6fa9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a9b3d1518a010dbb1c0d28d5360a6fa9f">randomReadPerformanceTest</a> (<a class="el" href="struct_s_k_t_benchmark_specific_setup.html">SKTBenchmarkSpecificSetup</a> &amp;benchSpec, <a class="el" href="struct_s_k_t_benchmark_report.html">SKTBenchmarkReport</a> &amp;reportInfo)</td></tr>
<tr class="memdesc:a9b3d1518a010dbb1c0d28d5360a6fa9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a random read test on the storage device and return performance data. <br />
The performance data is calculated based on the amount data read and duration of the test.  <a href="#a9b3d1518a010dbb1c0d28d5360a6fa9f">More...</a><br /></td></tr>
<tr class="separator:a9b3d1518a010dbb1c0d28d5360a6fa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe57641b0fab7b4088419a7c11f8978"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#abbe57641b0fab7b4088419a7c11f8978">randomWritePerformanceTest</a> (<a class="el" href="struct_s_k_t_benchmark_specific_setup.html">SKTBenchmarkSpecificSetup</a> &amp;benchSpec, <a class="el" href="struct_s_k_t_benchmark_report.html">SKTBenchmarkReport</a> &amp;reportInfo)</td></tr>
<tr class="memdesc:abbe57641b0fab7b4088419a7c11f8978"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a random write test on the storage device and return performance data. <br />
The performance data is calculated based on the amount data written and duration of the test.  <a href="#abbe57641b0fab7b4088419a7c11f8978">More...</a><br /></td></tr>
<tr class="separator:abbe57641b0fab7b4088419a7c11f8978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db3d4f4d578063fdd4f76878a380c29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a0db3d4f4d578063fdd4f76878a380c29">startMaxPowerConsumptionTest</a> (const <a class="el" href="_storage_kit_test_delegate_8h.html#a0bde7719e6307ceed4a51107ed3de2ef">SKTPowerConsumptionMode</a> &amp;mode)</td></tr>
<tr class="memdesc:a0db3d4f4d578063fdd4f76878a380c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the thread to create max power consumption condition on the SSD. There are two operating modes:  <a href="#a0db3d4f4d578063fdd4f76878a380c29">More...</a><br /></td></tr>
<tr class="separator:a0db3d4f4d578063fdd4f76878a380c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022692ef371a3aa9a24e19b5a5e129c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a022692ef371a3aa9a24e19b5a5e129c7">stopMaxPowerConsumptionTest</a> ()</td></tr>
<tr class="memdesc:a022692ef371a3aa9a24e19b5a5e129c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the thread is created previously by <a class="el" href="class_s_k_t_test_delegate.html#a0db3d4f4d578063fdd4f76878a380c29" title="Start the thread to create max power consumption condition on the SSD. There are two operating modes:">startMaxPowerConsumptionTest</a> function.  <a href="#a022692ef371a3aa9a24e19b5a5e129c7">More...</a><br /></td></tr>
<tr class="separator:a022692ef371a3aa9a24e19b5a5e129c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370b8ca0f86a90bc36101fd701b82609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a370b8ca0f86a90bc36101fd701b82609">ataSleep</a> ()</td></tr>
<tr class="memdesc:a370b8ca0f86a90bc36101fd701b82609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put device in sleep mode.  <a href="#a370b8ca0f86a90bc36101fd701b82609">More...</a><br /></td></tr>
<tr class="separator:a370b8ca0f86a90bc36101fd701b82609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d0c168749430e20f9bee211adc20da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a90d0c168749430e20f9bee211adc20da">startDiagnostic</a> (const std::string &amp;logFilePath)</td></tr>
<tr class="memdesc:a90d0c168749430e20f9bee211adc20da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the diagnostic. <br />
Start the thread to log collected data (SMART) periodically on a log file. Data (SMART) including UDMA CRC error count and ECC recovered.  <a href="#a90d0c168749430e20f9bee211adc20da">More...</a><br /></td></tr>
<tr class="separator:a90d0c168749430e20f9bee211adc20da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83eb8f0f40e0ba07f93bcc2bfbe3b14f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_k_t_test_delegate.html#a83eb8f0f40e0ba07f93bcc2bfbe3b14f">stopDiagnostic</a> ()</td></tr>
<tr class="memdesc:a83eb8f0f40e0ba07f93bcc2bfbe3b14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the thread is created previously by <a class="el" href="class_s_k_t_test_delegate.html#a90d0c168749430e20f9bee211adc20da" title="Start the diagnostic.  Start the thread to log collected data (SMART) periodically on a log file....">startDiagnostic</a> function.  <a href="#a83eb8f0f40e0ba07f93bcc2bfbe3b14f">More...</a><br /></td></tr>
<tr class="separator:a83eb8f0f40e0ba07f93bcc2bfbe3b14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>An object to support for Test Utilities. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aecc4032aaee08b7c6f8eb4b5d21c1816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc4032aaee08b7c6f8eb4b5d21c1816">&#9670;&nbsp;</a></span>SKTTestDelegate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SKTTestDelegate::SKTTestDelegate </td>
          <td>(</td>
          <td class="paramtype">SKStorageDevice *&#160;</td>
          <td class="paramname"><em>storageDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SKDeviceInfo *&#160;</td>
          <td class="paramname"><em>deviceInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loadWrittenLbasFromFile</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>freeStorageDevice</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that sets the storage device to a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storageDevice</td><td>A storage device object retrived from storage api (devices scanned). </td></tr>
    <tr><td class="paramname">deviceInfo</td><td>A device info object specifies information of the device. </td></tr>
    <tr><td class="paramname">loadWrittenDataFromFile</td><td>A bool variable to indicate whether written lbas load from file or initial new (default is true). </td></tr>
    <tr><td class="paramname">freeStorageDevice</td><td>A bool variable to indicate if storage device be freed up when this object destructs (default is true). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c0d861c72b763e76b2bde4c2f328989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0d861c72b763e76b2bde4c2f328989">&#9670;&nbsp;</a></span>~SKTTestDelegate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SKTTestDelegate::~SKTTestDelegate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor that frees up memory. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a77a53f075777687fa04173bc2efcd5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a53f075777687fa04173bc2efcd5ba">&#9670;&nbsp;</a></span>getDeviceInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const SKDeviceInfo* SKTTestDelegate::getDeviceInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get instance pointer of device info. </p>
<dl class="section return"><dt>Returns</dt><dd>The instance pointer of device info. </dd></dl>

</div>
</div>
<a id="a5dc6c0bb31013a0ecf4adf5506fa8524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc6c0bb31013a0ecf4adf5506fa8524">&#9670;&nbsp;</a></span>readLBA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::readLBA </td>
          <td>(</td>
          <td class="paramtype">U64&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>sectorCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SKAlignedBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to perform direct read from a storage device. <br />
User specifies logical block address, number of sectors, and provides a buffer that contains read contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">lba</td><td>An U64 variable contains logic block address. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sectorCount</td><td>An U32 variable contains sector count. The sector count can vary between 1 and 256. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>A buffer object which contains the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return code will indicate whether the function succeed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The maximum number of sector count up to 1024 in Linux system. </dd></dl>

</div>
</div>
<a id="a5f419fc0e074bf3faccf3163b1c55831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f419fc0e074bf3faccf3163b1c55831">&#9670;&nbsp;</a></span>writeLBA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::writeLBA </td>
          <td>(</td>
          <td class="paramtype">U64&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>sectorCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SKAlignedBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to perform direct write to a storage device. <br />
User specifies logical block address, number of sectors, and provides a buffer that contains write contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lba</td><td>An U64 variable contains logic block address. </td></tr>
    <tr><td class="paramname">sectorCount</td><td>An U32 variable contains sector count. The sector count can vary between 1 and 256. </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer object that contains the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A SKTTestReturnCode object to specify the return code.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The maximum number of sector count up to 1024 in Linux system. </dd></dl>

</div>
</div>
<a id="a0c1650ce1ef4c16593d4a950dc78dedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1650ce1ef4c16593d4a950dc78dedf">&#9670;&nbsp;</a></span>sequentialWriteWithUniquePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::sequentialWriteWithUniquePatterns </td>
          <td>(</td>
          <td class="paramtype">U64&#160;</td>
          <td class="paramname"><em>startLba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U64&#160;</td>
          <td class="paramname"><em>endLba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>blockSizeInKB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes unique data pattern for each LBA. <br />
The data (written lbas) will be marked and stored on file. This file will be used for verification of data integrity. The marked written lbas file format is the combination of the device model and '_lba.log'. <br />
The writes are sequential. This function is useful in the following situations: </p>
<ul>
<li>To verify if data is corrupt in case of sudden power loss.</li>
<li>To use with data retention test at power off. Write data to the drive and turn power off, read data from the drive later, and verify if the data is intact.</li>
<li>To verify if data is corrupt due to address trampling, bad garbage collection or bad wear leveling in firmware.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startLba</td><td>An U64 variable to specify a starting logical block address. </td></tr>
    <tr><td class="paramname">endLba</td><td>An U64 variable to specify an ending logical block address. </td></tr>
    <tr><td class="paramname">blockSizeInKB</td><td>The block size in kilobyte is the unit of I/O workload. Every read and write is done in multiples of the block size. The size can vary between 1KB and 128KB.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return code to indicate whether the function succeeded. If the function failed, the code indicates the reason for the failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For StorKit Revision 1.0, it only supports non NCQ benchmark. </dd>
<dd>
The maximum size of block size up to 512KB in Linux system. </dd></dl>

</div>
</div>
<a id="a5a6f15d6814f37378ba7a3b898cf41fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6f15d6814f37378ba7a3b898cf41fe">&#9670;&nbsp;</a></span>sequentialRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::sequentialRead </td>
          <td>(</td>
          <td class="paramtype">U64&#160;</td>
          <td class="paramname"><em>startLba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U64&#160;</td>
          <td class="paramname"><em>endLba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>blockSizeInKB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequential read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startLba</td><td>An U64 variable to specify a starting logical block address. </td></tr>
    <tr><td class="paramname">endLba</td><td>An U64 variable to specify an ending logical block address. </td></tr>
    <tr><td class="paramname">blockSizeInKB</td><td>The block size in kilobyte is the unit of I/O workload. Every read and write is done in multiples of the block size. The size can vary between 1KB and 128KB.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return code to indicate whether the function succeeded. If the function failed, the code indicates the reason for the failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The maximum size of block size up to 512KB in Linux system. </dd></dl>

</div>
</div>
<a id="a5a1208defc74b67bdb4b1c486dea6087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1208defc74b67bdb4b1c486dea6087">&#9670;&nbsp;</a></span>randomWriteWithUniquePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::randomWriteWithUniquePatterns </td>
          <td>(</td>
          <td class="paramtype">U64&#160;</td>
          <td class="paramname"><em>startLba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U64&#160;</td>
          <td class="paramname"><em>endLba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>blockSizeInKB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>sizeInMB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes unique data pattern for each LBA. <br />
The data (written LBAs) will be marked and stored on file. This file will be used for verification of data integrity. The marked written LBAs file format is the combination of the device model and '_lba.log'. <br />
The writes are random. This function is useful in the following situations: </p>
<ul>
<li>To verify if data is corrupt in case of sudden power loss.</li>
<li>To use with data retention test at power off. Write data to the drive and turn power off, read data from the drive later, and verify if the data is intact.</li>
<li>To verify if data is corrupt due to address trampling, bad garbage collection or bad wear leveling in firmware. This function writes data randomly, therefore, it makes it harder on the SSD.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startLba</td><td>An U64 variable to specify a starting logical block address. </td></tr>
    <tr><td class="paramname">endLba</td><td>An U64 variable to specify an ending logical block address. </td></tr>
    <tr><td class="paramname">blockSizeInKB</td><td>The block size in kilobyte is the unit of I/O workload. Every read and write is done in multiples of the block size. The size can vary between 1KB and 128KB. </td></tr>
    <tr><td class="paramname">sizeInMB</td><td>Size of total random write in MB. </td></tr>
    <tr><td class="paramname">seed</td><td>An U32 random seed that allow you to write the same random lba multiple times.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return code to indicate whether the function succeeded. If the function failed, the code indicates the reason for the failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For StorKit Revision 1.0, it only supports non NCQ benchmark. </dd></dl>

</div>
</div>
<a id="a093e3555e092155feb9c19f40f33e90d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093e3555e092155feb9c19f40f33e90d">&#9670;&nbsp;</a></span>randomRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::randomRead </td>
          <td>(</td>
          <td class="paramtype">U64&#160;</td>
          <td class="paramname"><em>startLba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U64&#160;</td>
          <td class="paramname"><em>endLba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>blockSizeInKB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>sizeInMB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startLba</td><td>An U64 variable to specify a starting logical block address. </td></tr>
    <tr><td class="paramname">endLba</td><td>An U64 variable to specify an ending logical block address. </td></tr>
    <tr><td class="paramname">blockSizeInKB</td><td>The block size in kilobyte is the unit of I/O workload. Every read and write is done in multiples of the block size. The size can vary between 1KB and 128KB. </td></tr>
    <tr><td class="paramname">sizeInMB</td><td>Size of total random write in MB. </td></tr>
    <tr><td class="paramname">seed</td><td>An U32 random seed that allow you to write and verify the same random lba multiple times.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return code to indicate whether the function succeeded. If the function failed, the code indicates the reason for the failure. </dd></dl>

</div>
</div>
<a id="a544ac08a737b1045095deb23b8e6ba5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544ac08a737b1045095deb23b8e6ba5d">&#9670;&nbsp;</a></span>verifyDataIntegrity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::verifyDataIntegrity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify data integrity. <br />
All marked written lbas will be read from the drive and use the information in the data itself to verify whether the data is OK or corrupted. </p>
<dl class="section return"><dt>Returns</dt><dd>The return code to indicate whether the function succeeded. If the function failed, the code indicates the reason for the failure. </dd></dl>

</div>
</div>
<a id="ad25f9f0d4aabe6c159b08c751c3fce6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25f9f0d4aabe6c159b08c751c3fce6a">&#9670;&nbsp;</a></span>cleanupWorkloadDataFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::cleanupWorkloadDataFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up workload data file which contains marked written lbas. </p>
<dl class="section return"><dt>Returns</dt><dd>The return code to indicate whether the function succeeded. If the function failed, the code indicates the reason for the failure. </dd></dl>

</div>
</div>
<a id="a352d1c5033473624451b30e54117d316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352d1c5033473624451b30e54117d316">&#9670;&nbsp;</a></span>sequentialReadPerformanceTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::sequentialReadPerformanceTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_k_t_benchmark_specific_setup.html">SKTBenchmarkSpecificSetup</a> &amp;&#160;</td>
          <td class="paramname"><em>benchSpec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_k_t_benchmark_report.html">SKTBenchmarkReport</a> &amp;&#160;</td>
          <td class="paramname"><em>reportInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a sequential read test on the storage device and return performance data. <br />
The performance data is calculated based on the amount data read and duration of the test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">benchSpec</td><td>Structure <a class="el" href="struct_s_k_t_benchmark_specific_setup.html" title="This set of parameters is using for IO workloads: sequential reads or random writes.">SKTBenchmarkSpecificSetup</a> contains setup information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reportInfo</td><td>Structure <a class="el" href="struct_s_k_t_benchmark_report.html" title="Declares performance results.">SKTBenchmarkReport</a> contains the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return code to indicate whether the function succeeded. If the function failed, the code indicates the reason for the failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For StorKit Revision 1.0, it only supports non NCQ benchmark. It means to measure the actual response time of the storage. </dd></dl>

</div>
</div>
<a id="a223a0b6bfc90fe5ccdd43e8e966daeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223a0b6bfc90fe5ccdd43e8e966daeb0">&#9670;&nbsp;</a></span>sequentialWritePerformanceTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::sequentialWritePerformanceTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_k_t_benchmark_specific_setup.html">SKTBenchmarkSpecificSetup</a> &amp;&#160;</td>
          <td class="paramname"><em>benchSpec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_k_t_benchmark_report.html">SKTBenchmarkReport</a> &amp;&#160;</td>
          <td class="paramname"><em>reportInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a sequential write test on the storage device and return performance data. <br />
The performance data is calculated based on the amount data written and duration of the test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">benchSpec</td><td>Structure <a class="el" href="struct_s_k_t_benchmark_specific_setup.html" title="This set of parameters is using for IO workloads: sequential reads or random writes.">SKTBenchmarkSpecificSetup</a> contains setup information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reportInfo</td><td>Structure <a class="el" href="struct_s_k_t_benchmark_report.html" title="Declares performance results.">SKTBenchmarkReport</a> contains the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return code to indicate whether the function succeeded. If the function failed, the code indicates the reason for the failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For StorKit Revision 1.0, it only supports non NCQ benchmark. It means to measure the actual response time of the storage. </dd></dl>

</div>
</div>
<a id="a9b3d1518a010dbb1c0d28d5360a6fa9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3d1518a010dbb1c0d28d5360a6fa9f">&#9670;&nbsp;</a></span>randomReadPerformanceTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::randomReadPerformanceTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_k_t_benchmark_specific_setup.html">SKTBenchmarkSpecificSetup</a> &amp;&#160;</td>
          <td class="paramname"><em>benchSpec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_k_t_benchmark_report.html">SKTBenchmarkReport</a> &amp;&#160;</td>
          <td class="paramname"><em>reportInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a random read test on the storage device and return performance data. <br />
The performance data is calculated based on the amount data read and duration of the test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">benchSpec</td><td>Structure <a class="el" href="struct_s_k_t_benchmark_specific_setup.html" title="This set of parameters is using for IO workloads: sequential reads or random writes.">SKTBenchmarkSpecificSetup</a> contains setup information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reportInfo</td><td>Structure <a class="el" href="struct_s_k_t_benchmark_report.html" title="Declares performance results.">SKTBenchmarkReport</a> contains the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return code to indicate whether the function succeeded. If the function failed, the code indicates the reason for the failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For StorKit Revision 1.0, it only supports non NCQ benchmark. It means to measure the actual response time of the storage. </dd></dl>

</div>
</div>
<a id="abbe57641b0fab7b4088419a7c11f8978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe57641b0fab7b4088419a7c11f8978">&#9670;&nbsp;</a></span>randomWritePerformanceTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::randomWritePerformanceTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_k_t_benchmark_specific_setup.html">SKTBenchmarkSpecificSetup</a> &amp;&#160;</td>
          <td class="paramname"><em>benchSpec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s_k_t_benchmark_report.html">SKTBenchmarkReport</a> &amp;&#160;</td>
          <td class="paramname"><em>reportInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs a random write test on the storage device and return performance data. <br />
The performance data is calculated based on the amount data written and duration of the test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">benchSpec</td><td>Structure <a class="el" href="struct_s_k_t_benchmark_specific_setup.html" title="This set of parameters is using for IO workloads: sequential reads or random writes.">SKTBenchmarkSpecificSetup</a> contains setup information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reportInfo</td><td>Structure <a class="el" href="struct_s_k_t_benchmark_report.html" title="Declares performance results.">SKTBenchmarkReport</a> contains the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return code to indicate whether the function succeeded. If the function failed, the code indicates the reason for the failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For StorKit Revision 1.0, it only supports non NCQ benchmark. It means to measure the actual response time of the storage. </dd></dl>

</div>
</div>
<a id="a0db3d4f4d578063fdd4f76878a380c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db3d4f4d578063fdd4f76878a380c29">&#9670;&nbsp;</a></span>startMaxPowerConsumptionTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::startMaxPowerConsumptionTest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_storage_kit_test_delegate_8h.html#a0bde7719e6307ceed4a51107ed3de2ef">SKTPowerConsumptionMode</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the thread to create max power consumption condition on the SSD. There are two operating modes: </p>
<ul>
<li>In Production mode: sequential write performed until reaching stop condition.</li>
<li>In Live mode: sequential read performed until reaching stop condition.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>A SKTPowerConsumptionMode object to specify power consumption mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A SKTTestReturnCode object to specify the return code.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The test will run until you invoke function <a class="el" href="class_s_k_t_test_delegate.html#a022692ef371a3aa9a24e19b5a5e129c7" title="Stop the thread is created previously by startMaxPowerConsumptionTest function.">stopMaxPowerConsumptionTest</a>. </dd></dl>

</div>
</div>
<a id="a022692ef371a3aa9a24e19b5a5e129c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022692ef371a3aa9a24e19b5a5e129c7">&#9670;&nbsp;</a></span>stopMaxPowerConsumptionTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::stopMaxPowerConsumptionTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the thread is created previously by <a class="el" href="class_s_k_t_test_delegate.html#a0db3d4f4d578063fdd4f76878a380c29" title="Start the thread to create max power consumption condition on the SSD. There are two operating modes:">startMaxPowerConsumptionTest</a> function. </p>
<dl class="section return"><dt>Returns</dt><dd>A SKTTestReturnCode object to specify the return code. </dd></dl>

</div>
</div>
<a id="a370b8ca0f86a90bc36101fd701b82609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370b8ca0f86a90bc36101fd701b82609">&#9670;&nbsp;</a></span>ataSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::ataSleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put device in sleep mode. </p>
<dl class="section return"><dt>Returns</dt><dd>A SKTTestReturnCode object to specify the return code. </dd></dl>

</div>
</div>
<a id="a90d0c168749430e20f9bee211adc20da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d0c168749430e20f9bee211adc20da">&#9670;&nbsp;</a></span>startDiagnostic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::startDiagnostic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>logFilePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the diagnostic. <br />
Start the thread to log collected data (SMART) periodically on a log file. Data (SMART) including UDMA CRC error count and ECC recovered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logFilePath</td><td>A string object to specify dump log file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A SKTTestReturnCode object to specify the return code.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The test will run until you invoke function <a class="el" href="class_s_k_t_test_delegate.html#a83eb8f0f40e0ba07f93bcc2bfbe3b14f" title="Stop the thread is created previously by startDiagnostic function.">stopDiagnostic</a>. </dd></dl>

</div>
</div>
<a id="a83eb8f0f40e0ba07f93bcc2bfbe3b14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83eb8f0f40e0ba07f93bcc2bfbe3b14f">&#9670;&nbsp;</a></span>stopDiagnostic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_storage_kit_test_delegate_8h.html#a143844aea21c1ac420c1d0307a69deb7">SKTReturnCode</a> SKTTestDelegate::stopDiagnostic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the thread is created previously by <a class="el" href="class_s_k_t_test_delegate.html#a90d0c168749430e20f9bee211adc20da" title="Start the diagnostic.  Start the thread to log collected data (SMART) periodically on a log file....">startDiagnostic</a> function. </p>
<dl class="section return"><dt>Returns</dt><dd>A SKTTestReturnCode object to specify the return code. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/tranminhtam/Documents/azure/StorageKit/test-delegate/include/<a class="el" href="_storage_kit_test_delegate_8h_source.html">StorageKitTestDelegate.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
